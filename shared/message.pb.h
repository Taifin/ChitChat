// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto;
namespace ChitChatMessage {
class Query;
struct QueryDefaultTypeInternal;
extern QueryDefaultTypeInternal _Query_default_instance_;
class Query_User;
struct Query_UserDefaultTypeInternal;
extern Query_UserDefaultTypeInternal _Query_User_default_instance_;
}  // namespace ChitChatMessage
PROTOBUF_NAMESPACE_OPEN
template<> ::ChitChatMessage::Query* Arena::CreateMaybeMessage<::ChitChatMessage::Query>(Arena*);
template<> ::ChitChatMessage::Query_User* Arena::CreateMaybeMessage<::ChitChatMessage::Query_User>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ChitChatMessage {

enum Query_RequestType : int {
  Query_RequestType_LOGIN = 0,
  Query_RequestType_REGISTER = 1,
  Query_RequestType_CONNECT = 3,
  Query_RequestType_MOVE = 4,
  Query_RequestType_DISCONNECT = 5,
  Query_RequestType_CHANGE_SKIN = 6,
  Query_RequestType_CHANGE_SCORE = 7,
  Query_RequestType_GET_SKIN = 8
};
bool Query_RequestType_IsValid(int value);
constexpr Query_RequestType Query_RequestType_RequestType_MIN = Query_RequestType_LOGIN;
constexpr Query_RequestType Query_RequestType_RequestType_MAX = Query_RequestType_GET_SKIN;
constexpr int Query_RequestType_RequestType_ARRAYSIZE = Query_RequestType_RequestType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Query_RequestType_descriptor();
template<typename T>
inline const std::string& Query_RequestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Query_RequestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Query_RequestType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Query_RequestType_descriptor(), enum_t_value);
}
inline bool Query_RequestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Query_RequestType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Query_RequestType>(
    Query_RequestType_descriptor(), name, value);
}
enum Query_FeedbackType : int {
  Query_FeedbackType_NO_USER_FOUND = -1,
  Query_FeedbackType_LOGIN_ALLOWED = 0,
  Query_FeedbackType_LOGIN_DENIED = 1,
  Query_FeedbackType_USER_CREATED = 2,
  Query_FeedbackType_USER_DUPLICATE = 3,
  Query_FeedbackType_CONNECTION_SUCCESS = 4,
  Query_FeedbackType_CONNECTION_EXISTS = 5,
  Query_FeedbackType_MOVED = 6,
  Query_FeedbackType_DISCONNECTED = 7,
  Query_FeedbackType_SKIN_CHANGED = 8,
  Query_FeedbackType_SCORE_CHANGED = 9,
  Query_FeedbackType_DATABASE_ERROR = 10,
  Query_FeedbackType_SKIN = 11,
  Query_FeedbackType_NEW_USER_CONNECTED = 12
};
bool Query_FeedbackType_IsValid(int value);
constexpr Query_FeedbackType Query_FeedbackType_FeedbackType_MIN = Query_FeedbackType_NO_USER_FOUND;
constexpr Query_FeedbackType Query_FeedbackType_FeedbackType_MAX = Query_FeedbackType_NEW_USER_CONNECTED;
constexpr int Query_FeedbackType_FeedbackType_ARRAYSIZE = Query_FeedbackType_FeedbackType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Query_FeedbackType_descriptor();
template<typename T>
inline const std::string& Query_FeedbackType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Query_FeedbackType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Query_FeedbackType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Query_FeedbackType_descriptor(), enum_t_value);
}
inline bool Query_FeedbackType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Query_FeedbackType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Query_FeedbackType>(
    Query_FeedbackType_descriptor(), name, value);
}
// ===================================================================

class Query_User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChitChatMessage.Query.User) */ {
 public:
  inline Query_User() : Query_User(nullptr) {}
  ~Query_User() override;
  explicit constexpr Query_User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Query_User(const Query_User& from);
  Query_User(Query_User&& from) noexcept
    : Query_User() {
    *this = ::std::move(from);
  }

  inline Query_User& operator=(const Query_User& from) {
    CopyFrom(from);
    return *this;
  }
  inline Query_User& operator=(Query_User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Query_User& default_instance() {
    return *internal_default_instance();
  }
  static inline const Query_User* internal_default_instance() {
    return reinterpret_cast<const Query_User*>(
               &_Query_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Query_User& a, Query_User& b) {
    a.Swap(&b);
  }
  inline void Swap(Query_User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Query_User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Query_User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Query_User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Query_User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Query_User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Query_User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChitChatMessage.Query.User";
  }
  protected:
  explicit Query_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kSkinFieldNumber = 3,
    kXCoordFieldNumber = 4,
    kYCoordFieldNumber = 5,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string password = 2 [default = "pwd"];
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional string skin = 3 [default = "kermit"];
  bool has_skin() const;
  private:
  bool _internal_has_skin() const;
  public:
  void clear_skin();
  const std::string& skin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_skin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_skin();
  PROTOBUF_NODISCARD std::string* release_skin();
  void set_allocated_skin(std::string* skin);
  private:
  const std::string& _internal_skin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_skin(const std::string& value);
  std::string* _internal_mutable_skin();
  public:

  // optional int32 x_coord = 4 [default = 0];
  bool has_x_coord() const;
  private:
  bool _internal_has_x_coord() const;
  public:
  void clear_x_coord();
  int32_t x_coord() const;
  void set_x_coord(int32_t value);
  private:
  int32_t _internal_x_coord() const;
  void _internal_set_x_coord(int32_t value);
  public:

  // optional int32 y_coord = 5 [default = 0];
  bool has_y_coord() const;
  private:
  bool _internal_has_y_coord() const;
  public:
  void clear_y_coord();
  int32_t y_coord() const;
  void set_y_coord(int32_t value);
  private:
  int32_t _internal_y_coord() const;
  void _internal_set_y_coord(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChitChatMessage.Query.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_skin_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr skin_;
  int32_t x_coord_;
  int32_t y_coord_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class Query final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChitChatMessage.Query) */ {
 public:
  inline Query() : Query(nullptr) {}
  ~Query() override;
  explicit constexpr Query(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Query(const Query& from);
  Query(Query&& from) noexcept
    : Query() {
    *this = ::std::move(from);
  }

  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }
  inline Query& operator=(Query&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Query& default_instance() {
    return *internal_default_instance();
  }
  static inline const Query* internal_default_instance() {
    return reinterpret_cast<const Query*>(
               &_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Query& a, Query& b) {
    a.Swap(&b);
  }
  inline void Swap(Query* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Query* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Query* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Query>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Query& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Query& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Query* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChitChatMessage.Query";
  }
  protected:
  explicit Query(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Query_User User;

  typedef Query_RequestType RequestType;
  static constexpr RequestType LOGIN =
    Query_RequestType_LOGIN;
  static constexpr RequestType REGISTER =
    Query_RequestType_REGISTER;
  static constexpr RequestType CONNECT =
    Query_RequestType_CONNECT;
  static constexpr RequestType MOVE =
    Query_RequestType_MOVE;
  static constexpr RequestType DISCONNECT =
    Query_RequestType_DISCONNECT;
  static constexpr RequestType CHANGE_SKIN =
    Query_RequestType_CHANGE_SKIN;
  static constexpr RequestType CHANGE_SCORE =
    Query_RequestType_CHANGE_SCORE;
  static constexpr RequestType GET_SKIN =
    Query_RequestType_GET_SKIN;
  static inline bool RequestType_IsValid(int value) {
    return Query_RequestType_IsValid(value);
  }
  static constexpr RequestType RequestType_MIN =
    Query_RequestType_RequestType_MIN;
  static constexpr RequestType RequestType_MAX =
    Query_RequestType_RequestType_MAX;
  static constexpr int RequestType_ARRAYSIZE =
    Query_RequestType_RequestType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RequestType_descriptor() {
    return Query_RequestType_descriptor();
  }
  template<typename T>
  static inline const std::string& RequestType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RequestType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RequestType_Name.");
    return Query_RequestType_Name(enum_t_value);
  }
  static inline bool RequestType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RequestType* value) {
    return Query_RequestType_Parse(name, value);
  }

  typedef Query_FeedbackType FeedbackType;
  static constexpr FeedbackType NO_USER_FOUND =
    Query_FeedbackType_NO_USER_FOUND;
  static constexpr FeedbackType LOGIN_ALLOWED =
    Query_FeedbackType_LOGIN_ALLOWED;
  static constexpr FeedbackType LOGIN_DENIED =
    Query_FeedbackType_LOGIN_DENIED;
  static constexpr FeedbackType USER_CREATED =
    Query_FeedbackType_USER_CREATED;
  static constexpr FeedbackType USER_DUPLICATE =
    Query_FeedbackType_USER_DUPLICATE;
  static constexpr FeedbackType CONNECTION_SUCCESS =
    Query_FeedbackType_CONNECTION_SUCCESS;
  static constexpr FeedbackType CONNECTION_EXISTS =
    Query_FeedbackType_CONNECTION_EXISTS;
  static constexpr FeedbackType MOVED =
    Query_FeedbackType_MOVED;
  static constexpr FeedbackType DISCONNECTED =
    Query_FeedbackType_DISCONNECTED;
  static constexpr FeedbackType SKIN_CHANGED =
    Query_FeedbackType_SKIN_CHANGED;
  static constexpr FeedbackType SCORE_CHANGED =
    Query_FeedbackType_SCORE_CHANGED;
  static constexpr FeedbackType DATABASE_ERROR =
    Query_FeedbackType_DATABASE_ERROR;
  static constexpr FeedbackType SKIN =
    Query_FeedbackType_SKIN;
  static constexpr FeedbackType NEW_USER_CONNECTED =
    Query_FeedbackType_NEW_USER_CONNECTED;
  static inline bool FeedbackType_IsValid(int value) {
    return Query_FeedbackType_IsValid(value);
  }
  static constexpr FeedbackType FeedbackType_MIN =
    Query_FeedbackType_FeedbackType_MIN;
  static constexpr FeedbackType FeedbackType_MAX =
    Query_FeedbackType_FeedbackType_MAX;
  static constexpr int FeedbackType_ARRAYSIZE =
    Query_FeedbackType_FeedbackType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FeedbackType_descriptor() {
    return Query_FeedbackType_descriptor();
  }
  template<typename T>
  static inline const std::string& FeedbackType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FeedbackType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FeedbackType_Name.");
    return Query_FeedbackType_Name(enum_t_value);
  }
  static inline bool FeedbackType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FeedbackType* value) {
    return Query_FeedbackType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 4,
    kGameNameFieldNumber = 6,
    kUserFieldNumber = 3,
    kRTypeFieldNumber = 1,
    kScoreFieldNumber = 5,
    kFTypeFieldNumber = 2,
  };
  // repeated .ChitChatMessage.Query.User users = 4;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::ChitChatMessage::Query_User* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChitChatMessage::Query_User >*
      mutable_users();
  private:
  const ::ChitChatMessage::Query_User& _internal_users(int index) const;
  ::ChitChatMessage::Query_User* _internal_add_users();
  public:
  const ::ChitChatMessage::Query_User& users(int index) const;
  ::ChitChatMessage::Query_User* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChitChatMessage::Query_User >&
      users() const;

  // optional string game_name = 6;
  bool has_game_name() const;
  private:
  bool _internal_has_game_name() const;
  public:
  void clear_game_name();
  const std::string& game_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_name();
  PROTOBUF_NODISCARD std::string* release_game_name();
  void set_allocated_game_name(std::string* game_name);
  private:
  const std::string& _internal_game_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_name(const std::string& value);
  std::string* _internal_mutable_game_name();
  public:

  // required .ChitChatMessage.Query.User user = 3;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::ChitChatMessage::Query_User& user() const;
  PROTOBUF_NODISCARD ::ChitChatMessage::Query_User* release_user();
  ::ChitChatMessage::Query_User* mutable_user();
  void set_allocated_user(::ChitChatMessage::Query_User* user);
  private:
  const ::ChitChatMessage::Query_User& _internal_user() const;
  ::ChitChatMessage::Query_User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::ChitChatMessage::Query_User* user);
  ::ChitChatMessage::Query_User* unsafe_arena_release_user();

  // optional .ChitChatMessage.Query.RequestType rType = 1;
  bool has_rtype() const;
  private:
  bool _internal_has_rtype() const;
  public:
  void clear_rtype();
  ::ChitChatMessage::Query_RequestType rtype() const;
  void set_rtype(::ChitChatMessage::Query_RequestType value);
  private:
  ::ChitChatMessage::Query_RequestType _internal_rtype() const;
  void _internal_set_rtype(::ChitChatMessage::Query_RequestType value);
  public:

  // optional int32 score = 5;
  bool has_score() const;
  private:
  bool _internal_has_score() const;
  public:
  void clear_score();
  int32_t score() const;
  void set_score(int32_t value);
  private:
  int32_t _internal_score() const;
  void _internal_set_score(int32_t value);
  public:

  // optional .ChitChatMessage.Query.FeedbackType fType = 2;
  bool has_ftype() const;
  private:
  bool _internal_has_ftype() const;
  public:
  void clear_ftype();
  ::ChitChatMessage::Query_FeedbackType ftype() const;
  void set_ftype(::ChitChatMessage::Query_FeedbackType value);
  private:
  ::ChitChatMessage::Query_FeedbackType _internal_ftype() const;
  void _internal_set_ftype(::ChitChatMessage::Query_FeedbackType value);
  public:

  // @@protoc_insertion_point(class_scope:ChitChatMessage.Query)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChitChatMessage::Query_User > users_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_name_;
  ::ChitChatMessage::Query_User* user_;
  int rtype_;
  int32_t score_;
  int ftype_;
  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Query_User

// required string name = 1;
inline bool Query_User::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Query_User::has_name() const {
  return _internal_has_name();
}
inline void Query_User::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Query_User::name() const {
  // @@protoc_insertion_point(field_get:ChitChatMessage.Query.User.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Query_User::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChitChatMessage.Query.User.name)
}
inline std::string* Query_User::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ChitChatMessage.Query.User.name)
  return _s;
}
inline const std::string& Query_User::_internal_name() const {
  return name_.Get();
}
inline void Query_User::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Query_User::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Query_User::release_name() {
  // @@protoc_insertion_point(field_release:ChitChatMessage.Query.User.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Query_User::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChitChatMessage.Query.User.name)
}

// optional string password = 2 [default = "pwd"];
inline bool Query_User::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Query_User::has_password() const {
  return _internal_has_password();
}
inline void Query_User::clear_password() {
  password_.ClearToDefault(::ChitChatMessage::Query_User::_i_give_permission_to_break_this_code_default_password_, GetArenaForAllocation());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Query_User::password() const {
  // @@protoc_insertion_point(field_get:ChitChatMessage.Query.User.password)
  if (password_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_password_.get();
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Query_User::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChitChatMessage.Query.User.password)
}
inline std::string* Query_User::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:ChitChatMessage.Query.User.password)
  return _s;
}
inline const std::string& Query_User::_internal_password() const {
  return password_.Get();
}
inline void Query_User::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Query_User::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  return password_.Mutable(::ChitChatMessage::Query_User::_i_give_permission_to_break_this_code_default_password_, GetArenaForAllocation());
}
inline std::string* Query_User::release_password() {
  // @@protoc_insertion_point(field_release:ChitChatMessage.Query.User.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = password_.ReleaseNonDefault(nullptr, GetArenaForAllocation());
  return p;
}
inline void Query_User::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocated(nullptr, password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ChitChatMessage.Query.User.password)
}

// optional string skin = 3 [default = "kermit"];
inline bool Query_User::_internal_has_skin() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Query_User::has_skin() const {
  return _internal_has_skin();
}
inline void Query_User::clear_skin() {
  skin_.ClearToDefault(::ChitChatMessage::Query_User::_i_give_permission_to_break_this_code_default_skin_, GetArenaForAllocation());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Query_User::skin() const {
  // @@protoc_insertion_point(field_get:ChitChatMessage.Query.User.skin)
  if (skin_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_skin_.get();
  return _internal_skin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Query_User::set_skin(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 skin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChitChatMessage.Query.User.skin)
}
inline std::string* Query_User::mutable_skin() {
  std::string* _s = _internal_mutable_skin();
  // @@protoc_insertion_point(field_mutable:ChitChatMessage.Query.User.skin)
  return _s;
}
inline const std::string& Query_User::_internal_skin() const {
  return skin_.Get();
}
inline void Query_User::_internal_set_skin(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  skin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Query_User::_internal_mutable_skin() {
  _has_bits_[0] |= 0x00000004u;
  return skin_.Mutable(::ChitChatMessage::Query_User::_i_give_permission_to_break_this_code_default_skin_, GetArenaForAllocation());
}
inline std::string* Query_User::release_skin() {
  // @@protoc_insertion_point(field_release:ChitChatMessage.Query.User.skin)
  if (!_internal_has_skin()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = skin_.ReleaseNonDefault(nullptr, GetArenaForAllocation());
  return p;
}
inline void Query_User::set_allocated_skin(std::string* skin) {
  if (skin != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  skin_.SetAllocated(nullptr, skin,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ChitChatMessage.Query.User.skin)
}

// optional int32 x_coord = 4 [default = 0];
inline bool Query_User::_internal_has_x_coord() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Query_User::has_x_coord() const {
  return _internal_has_x_coord();
}
inline void Query_User::clear_x_coord() {
  x_coord_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t Query_User::_internal_x_coord() const {
  return x_coord_;
}
inline int32_t Query_User::x_coord() const {
  // @@protoc_insertion_point(field_get:ChitChatMessage.Query.User.x_coord)
  return _internal_x_coord();
}
inline void Query_User::_internal_set_x_coord(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  x_coord_ = value;
}
inline void Query_User::set_x_coord(int32_t value) {
  _internal_set_x_coord(value);
  // @@protoc_insertion_point(field_set:ChitChatMessage.Query.User.x_coord)
}

// optional int32 y_coord = 5 [default = 0];
inline bool Query_User::_internal_has_y_coord() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Query_User::has_y_coord() const {
  return _internal_has_y_coord();
}
inline void Query_User::clear_y_coord() {
  y_coord_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t Query_User::_internal_y_coord() const {
  return y_coord_;
}
inline int32_t Query_User::y_coord() const {
  // @@protoc_insertion_point(field_get:ChitChatMessage.Query.User.y_coord)
  return _internal_y_coord();
}
inline void Query_User::_internal_set_y_coord(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  y_coord_ = value;
}
inline void Query_User::set_y_coord(int32_t value) {
  _internal_set_y_coord(value);
  // @@protoc_insertion_point(field_set:ChitChatMessage.Query.User.y_coord)
}

// -------------------------------------------------------------------

// Query

// optional .ChitChatMessage.Query.RequestType rType = 1;
inline bool Query::_internal_has_rtype() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Query::has_rtype() const {
  return _internal_has_rtype();
}
inline void Query::clear_rtype() {
  rtype_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::ChitChatMessage::Query_RequestType Query::_internal_rtype() const {
  return static_cast< ::ChitChatMessage::Query_RequestType >(rtype_);
}
inline ::ChitChatMessage::Query_RequestType Query::rtype() const {
  // @@protoc_insertion_point(field_get:ChitChatMessage.Query.rType)
  return _internal_rtype();
}
inline void Query::_internal_set_rtype(::ChitChatMessage::Query_RequestType value) {
  assert(::ChitChatMessage::Query_RequestType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  rtype_ = value;
}
inline void Query::set_rtype(::ChitChatMessage::Query_RequestType value) {
  _internal_set_rtype(value);
  // @@protoc_insertion_point(field_set:ChitChatMessage.Query.rType)
}

// optional .ChitChatMessage.Query.FeedbackType fType = 2;
inline bool Query::_internal_has_ftype() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Query::has_ftype() const {
  return _internal_has_ftype();
}
inline void Query::clear_ftype() {
  ftype_ = -1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::ChitChatMessage::Query_FeedbackType Query::_internal_ftype() const {
  return static_cast< ::ChitChatMessage::Query_FeedbackType >(ftype_);
}
inline ::ChitChatMessage::Query_FeedbackType Query::ftype() const {
  // @@protoc_insertion_point(field_get:ChitChatMessage.Query.fType)
  return _internal_ftype();
}
inline void Query::_internal_set_ftype(::ChitChatMessage::Query_FeedbackType value) {
  assert(::ChitChatMessage::Query_FeedbackType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  ftype_ = value;
}
inline void Query::set_ftype(::ChitChatMessage::Query_FeedbackType value) {
  _internal_set_ftype(value);
  // @@protoc_insertion_point(field_set:ChitChatMessage.Query.fType)
}

// required .ChitChatMessage.Query.User user = 3;
inline bool Query::_internal_has_user() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || user_ != nullptr);
  return value;
}
inline bool Query::has_user() const {
  return _internal_has_user();
}
inline void Query::clear_user() {
  if (user_ != nullptr) user_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ChitChatMessage::Query_User& Query::_internal_user() const {
  const ::ChitChatMessage::Query_User* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::ChitChatMessage::Query_User&>(
      ::ChitChatMessage::_Query_User_default_instance_);
}
inline const ::ChitChatMessage::Query_User& Query::user() const {
  // @@protoc_insertion_point(field_get:ChitChatMessage.Query.user)
  return _internal_user();
}
inline void Query::unsafe_arena_set_allocated_user(
    ::ChitChatMessage::Query_User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChitChatMessage.Query.user)
}
inline ::ChitChatMessage::Query_User* Query::release_user() {
  _has_bits_[0] &= ~0x00000002u;
  ::ChitChatMessage::Query_User* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ChitChatMessage::Query_User* Query::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:ChitChatMessage.Query.user)
  _has_bits_[0] &= ~0x00000002u;
  ::ChitChatMessage::Query_User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::ChitChatMessage::Query_User* Query::_internal_mutable_user() {
  _has_bits_[0] |= 0x00000002u;
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChitChatMessage::Query_User>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::ChitChatMessage::Query_User* Query::mutable_user() {
  ::ChitChatMessage::Query_User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:ChitChatMessage.Query.user)
  return _msg;
}
inline void Query::set_allocated_user(::ChitChatMessage::Query_User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ChitChatMessage::Query_User>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:ChitChatMessage.Query.user)
}

// repeated .ChitChatMessage.Query.User users = 4;
inline int Query::_internal_users_size() const {
  return users_.size();
}
inline int Query::users_size() const {
  return _internal_users_size();
}
inline void Query::clear_users() {
  users_.Clear();
}
inline ::ChitChatMessage::Query_User* Query::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:ChitChatMessage.Query.users)
  return users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChitChatMessage::Query_User >*
Query::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:ChitChatMessage.Query.users)
  return &users_;
}
inline const ::ChitChatMessage::Query_User& Query::_internal_users(int index) const {
  return users_.Get(index);
}
inline const ::ChitChatMessage::Query_User& Query::users(int index) const {
  // @@protoc_insertion_point(field_get:ChitChatMessage.Query.users)
  return _internal_users(index);
}
inline ::ChitChatMessage::Query_User* Query::_internal_add_users() {
  return users_.Add();
}
inline ::ChitChatMessage::Query_User* Query::add_users() {
  ::ChitChatMessage::Query_User* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:ChitChatMessage.Query.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChitChatMessage::Query_User >&
Query::users() const {
  // @@protoc_insertion_point(field_list:ChitChatMessage.Query.users)
  return users_;
}

// optional int32 score = 5;
inline bool Query::_internal_has_score() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Query::has_score() const {
  return _internal_has_score();
}
inline void Query::clear_score() {
  score_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t Query::_internal_score() const {
  return score_;
}
inline int32_t Query::score() const {
  // @@protoc_insertion_point(field_get:ChitChatMessage.Query.score)
  return _internal_score();
}
inline void Query::_internal_set_score(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  score_ = value;
}
inline void Query::set_score(int32_t value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:ChitChatMessage.Query.score)
}

// optional string game_name = 6;
inline bool Query::_internal_has_game_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Query::has_game_name() const {
  return _internal_has_game_name();
}
inline void Query::clear_game_name() {
  game_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Query::game_name() const {
  // @@protoc_insertion_point(field_get:ChitChatMessage.Query.game_name)
  return _internal_game_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Query::set_game_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 game_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChitChatMessage.Query.game_name)
}
inline std::string* Query::mutable_game_name() {
  std::string* _s = _internal_mutable_game_name();
  // @@protoc_insertion_point(field_mutable:ChitChatMessage.Query.game_name)
  return _s;
}
inline const std::string& Query::_internal_game_name() const {
  return game_name_.Get();
}
inline void Query::_internal_set_game_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  game_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Query::_internal_mutable_game_name() {
  _has_bits_[0] |= 0x00000001u;
  return game_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Query::release_game_name() {
  // @@protoc_insertion_point(field_release:ChitChatMessage.Query.game_name)
  if (!_internal_has_game_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = game_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Query::set_allocated_game_name(std::string* game_name) {
  if (game_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  game_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChitChatMessage.Query.game_name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ChitChatMessage

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ChitChatMessage::Query_RequestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ChitChatMessage::Query_RequestType>() {
  return ::ChitChatMessage::Query_RequestType_descriptor();
}
template <> struct is_proto_enum< ::ChitChatMessage::Query_FeedbackType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ChitChatMessage::Query_FeedbackType>() {
  return ::ChitChatMessage::Query_FeedbackType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2eproto
